name: macos-26-arm64-single-precision-qt-bundled

on: workflow_dispatch

env:
  # Customize the CMake build type here (Release, Debug, RelWithDebInfo, etc.)
  BUILD_TYPE: Release
  OPENSPACE_VERSION: "0.21.3plus"
  THIS_REPO_PATH: "/Users/runner/work/OpenSpace-AppImage/OpenSpace-AppImage" 
  
jobs:
  build:
    runs-on: macos-26

    steps:
    - uses: actions/checkout@v4
    
    - name: get openspace code for a particular release
      run: |
        df -h
        openSpaceHome="$HOME/source/OpenSpace"
        git clone --recursive https://github.com/OpenSpace/OpenSpace.git "$openSpaceHome"
        cd "$openSpaceHome"
        git checkout master --recurse-submodules
        mkdir build
        cd build

    - name: patches for MacOS
      run: |
        openSpaceHome="$HOME/source/OpenSpace"
        cp -v MacOS-patches/reverse_patch.py "$openSpaceHome/reverse_patch.py"
        cp -v MacOS-patches/MacOS-reverse-diff-edited.patch "$openSpaceHome/MacOS-reverse-diff-edited.patch"
        cd "$openSpaceHome"
        python3 reverse_patch.py MacOS-reverse-diff-edited.patch

    - name: smart_patcher for MacOS
      run: |
        openSpaceHome="$HOME/source/OpenSpace"
        cp -v MacOS-patches/smart_patcher.py "$openSpaceHome/smart_patcher.py"
        cp -v MacOS-patches/MacOS-patches.txt "$openSpaceHome/MacOS-patches.txt"
        cd "$openSpaceHome"
        python3 smart_patcher.py MacOS-patches.txt        
        
    - name: get the single precision patches
      run: |
        openSpaceHome="$HOME/source/OpenSpace"
        cd "$openSpaceHome"
        git clone https://github.com/hn-88/OpenSpace-single-precision.git
        cd OpenSpace-single-precision
        cp -v ghoul-patches/* "$openSpaceHome"
        cp -v diff-files/* "$openSpaceHome"
        cd "$openSpaceHome"
        mv -v uniform_conversion.h ext/ghoul/src/opengl/uniform_conversion.h
        mv -v ghoul-src-opengl-programobject.cpp ext/ghoul/src/opengl/programobject.cpp
        python smart_patcher.py applesilicon.diffedited.txt
        # check for doubles in glsl files which might have remained
        GREP_OUTPUT=$(grep -rEn --include="*.glsl" --include="*.hglsl" --color=always "\b(double|dvec[234]?|dmat[234]?)\b" . || true)
        if [ -n "$GREP_OUTPUT" ]; then
          echo "Warning: Found double precision types in GLSL files:"
          echo "$GREP_OUTPUT"
        else
          echo "✓ No double precision types found in GLSL files"
        fi
        echo "Running smart_patcher for shader edits..."
        python smart_patcher.py changes-to-shadersv2.diff
        
    - name: Update Homebrew and Install GLM
      run: |
        brew update
        brew install glm
    
    - name: Cache Homebrew downloads 
      uses: actions/cache@v3 
      with: 
        path: | 
          ~/Library/Caches/Homebrew 
          /usr/local/Homebrew 
        key: macos26-cmake4-brew-v1
        restore-keys: | 
          macos26-cmake4-brew-
            
    - name: Install dependencies
      timeout-minutes: 30
      run: |
        brew install glew boost freeimage mpv vulkan-headers vulkan-loader brotli gdal qt@6 dylibbundler
        df -h

    - name: Configure CMake
      run: |
        openSpaceHome="$HOME/source/OpenSpace"
        cd "$openSpaceHome/build"
        cmake -G Xcode \
                  -Wno-dev \
                  -DCMAKE_POLICY_VERSION_MINIMUM=3.5 \
                  -DCMAKE_CXX_STANDARD=20 \
                  -DONLY_ACTIVE_ARCH=YES \
                  -DCMAKE_OSX_ARCHITECTURES=arm64 \
                  -DCMAKE_OSX_DEPLOYMENT_TARGET=14.0 \
                  -DCMAKE_CXX_FLAGS="-Wno-error -D_FILE_OFFSET_BITS=64" \
                  -DCMAKE_C_FLAGS="-Wno-error -D_FILE_OFFSET_BITS=64" \
                  -DCMAKE_BUILD_TYPE="Release" \
                  -DCMAKE_PREFIX_PATH=/opt/homebrew \
                  -DBUILD_TESTS=OFF \
                  -DCOMPILE_WARNING_AS_ERROR=OFF \
                  -DOPENSPACE_HAVE_TESTS=OFF \
                  -DSGCT_BUILD_TESTS=OFF \
                  -DSGCT_DEP_INCLUDE_LIBPNG=OFF \
                  -DPNG_PNG_INCLUDE_DIR=$(brew --prefix libpng)/include \
                  "$openSpaceHome"
    
    - name: Build
      run: |
        openSpaceHome="$HOME/source/OpenSpace"
        cd "$openSpaceHome/build"
        cmake --build . --config ${{env.BUILD_TYPE}} -- -quiet
        df -h

    - name: run macdeployqt and recursive bundling
      shell: bash
      run: |
        openSpaceHome="$HOME/source/OpenSpace"
        cd "$openSpaceHome"
        echo "### Bundling the QT libraries with macdeployqt"
    
        echo "/opt/homebrew/opt/qt@6/bin" >> $GITHUB_PATH
        which macdeployqt
    
        # Define variables
        APP_NAME="OpenSpace"
        APP_BUNDLE_PATH="bin/Release/$APP_NAME.app"
        
        # Verify the app bundle exists
        if [ ! -d "$APP_BUNDLE_PATH" ]; then
            echo "ERROR: App bundle not found at $APP_BUNDLE_PATH"
            ls -la bin/Release/ || ls -la bin/ || true
            exit 1
        fi
        
        APP_EXECUTABLE="$APP_BUNDLE_PATH/Contents/MacOS/OpenSpace"
        FRAMEWORKS_PATH="$APP_BUNDLE_PATH/Contents/Frameworks"
        
        # Auto-detect Qt Library Path
        QT_PATH=$(qmake -query QT_INSTALL_LIBS)
        echo "Qt Lib Path detected: $QT_PATH"
        
        echo "### 0. Initial cleanup..."
        mkdir -p "$FRAMEWORKS_PATH"
        
        # Remove all existing signatures to start fresh
        echo "Removing all existing signatures..."
        codesign --remove-signature "$APP_BUNDLE_PATH" 2>/dev/null || true
        find "$APP_BUNDLE_PATH" \( -name "*.dylib" -o -name "*.framework" -o -name "*.app" \) -exec codesign --remove-signature {} \; 2>/dev/null || true
        
        echo "### Running macdeployqt..."
        # Run macdeployqt WITHOUT signing
        macdeployqt "$APP_BUNDLE_PATH" -verbose=1 -always-overwrite || true
        
        echo "### 1. Manually Bundling QtDBus..."
        # (Keeping your original manual fix for QtDBus structure as it is specific and working)
        QTDBUS_SOURCE="$QT_PATH/QtDBus.framework"
        QTDBUS_DEST="$FRAMEWORKS_PATH/QtDBus.framework"
        
        if [ -L "$QTDBUS_SOURCE" ]; then
            QTDBUS_SOURCE_REAL=$(readlink -f "$QTDBUS_SOURCE" 2>/dev/null || greadlink -f "$QTDBUS_SOURCE" 2>/dev/null)
            if [ -n "$QTDBUS_SOURCE_REAL" ] && [ -d "$QTDBUS_SOURCE_REAL" ]; then
                QTDBUS_SOURCE="$QTDBUS_SOURCE_REAL"
            fi
        fi
        
        if [ -d "$QTDBUS_SOURCE" ]; then
            if [ -e "$QTDBUS_DEST" ]; then rm -rf "$QTDBUS_DEST"; fi
            echo "Creating proper QtDBus.framework structure..."
            mkdir -p "$QTDBUS_DEST/Versions/A"
            if [ -f "$QTDBUS_SOURCE/Versions/A/QtDBus" ]; then
                cp "$QTDBUS_SOURCE/Versions/A/QtDBus" "$QTDBUS_DEST/Versions/A/"
            elif [ -L "$QTDBUS_SOURCE/QtDBus" ]; then
                cp -L "$QTDBUS_SOURCE/QtDBus" "$QTDBUS_DEST/Versions/A/QtDBus"
            fi
            if [ -d "$QTDBUS_SOURCE/Versions/A/Resources" ]; then
                cp -R "$QTDBUS_SOURCE/Versions/A/Resources" "$QTDBUS_DEST/Versions/A/"
            elif [ -d "$QTDBUS_SOURCE/Resources" ] && [ ! -L "$QTDBUS_SOURCE/Resources" ]; then
                cp -R "$QTDBUS_SOURCE/Resources" "$QTDBUS_DEST/Versions/A/"
            fi
            chmod -R u+w "$QTDBUS_DEST"
            cd "$QTDBUS_DEST"
            ln -sf Versions/A/QtDBus QtDBus
            if [ -d "Versions/A/Resources" ]; then ln -sf Versions/A/Resources Resources; fi
            cd "$openSpaceHome"
            QTDBUS_LIB="$QTDBUS_DEST/Versions/A/QtDBus"
            if [ -f "$QTDBUS_LIB" ]; then
                install_name_tool -id "@rpath/QtDBus.framework/Versions/A/QtDBus" "$QTDBUS_LIB"
            fi
        else
            echo "ERROR: QtDBus source not found"
        fi

        # ==============================================================================
        # REPLACEMENT SECTION: RECURSIVE DEPENDENCY WALKING + RPATH CLEANUP
        # ==============================================================================
        
        echo "### 3. Advanced Dependency Bundling & RPath Cleanup"
        
        # Where to search for missing libs
        SEARCH_PATHS=(
            "/opt/homebrew/lib"
            "/usr/local/lib"
            "$QT_PATH"
        )
        echo "Search paths for dependencies: ${SEARCH_PATHS[*]}"

        # --- PART A: HELPER FUNCTIONS ---

        find_library_path() {
            local lib_name=$(basename "$1")
            if [ -f "$1" ]; then echo "$1"; return 0; fi
            for path in "${SEARCH_PATHS[@]}"; do
                if [ -f "$path/$lib_name" ]; then echo "$path/$lib_name"; return 0; fi
            done
            return 1
        }

        clean_rpaths() {
            local binary="$1"
            # Get raw list of rpaths
            local raw_rpaths=$(otool -l "$binary" | grep -A2 LC_RPATH | grep "path " | sed 's/ *path \(.*\) (offset.*)/\1/')
            
            declare -a seen_paths
            
            while read -r rpath; do
                [ -z "$rpath" ] && continue
                # Normalize: Remove trailing slash
                local norm_rpath="${rpath%/}"
                local is_duplicate=0
                for seen in "${seen_paths[@]}"; do
                    if [ "$seen" == "$norm_rpath" ]; then is_duplicate=1; break; fi
                done
                
                if [ $is_duplicate -eq 1 ]; then
                    install_name_tool -delete_rpath "$rpath" "$binary" 2>/dev/null || true
                else
                    if [ "$rpath" != "$norm_rpath" ]; then
                         install_name_tool -delete_rpath "$rpath" "$binary" 2>/dev/null || true
                         install_name_tool -add_rpath "$norm_rpath" "$binary" 2>/dev/null || true
                    fi
                    seen_paths+=("$norm_rpath")
                fi
            done <<< "$raw_rpaths"
        }

        # --- PART B: RECURSIVE DEPENDENCY WALKING ---
        
        echo "Starting Recursive Dependency Scan..."
        ITERATION=0
        MAX_ITERATIONS=10
        
        while [ $ITERATION -lt $MAX_ITERATIONS ]; do
            ITERATION=$((ITERATION+1))
            echo "--- Scan Iteration $ITERATION ---"
            CHANGES_MADE=false

            # Find all binaries (Executable + Dylibs + .so)
            BINARIES=$(find "$APP_BUNDLE_PATH" -type f \( -perm +111 -o -name "*.dylib" -o -name "*.so" \) | grep -v "Headers" | grep -v ".prl" | grep -v ".h")

            for BINARY in $BINARIES; do
                DEPS=$(otool -L "$BINARY" | grep -v ":" | awk '{print $1}')
                for DEP in $DEPS; do
                    if [[ "$DEP" == "/System/"* ]] || [[ "$DEP" == "/usr/lib/"* ]]; then continue; fi
                    
                    DEP_NAME=$(basename "$DEP")
                    IS_Bundled=false
                    if [ -f "$FRAMEWORKS_PATH/$DEP_NAME" ]; then IS_Bundled=true; fi

                    # Case 1: Dependency is NOT bundled yet
                    if [ "$IS_Bundled" = false ]; then
                        SOURCE_PATH=$(find_library_path "$DEP" || find_library_path "$DEP_NAME")
                        
                        if [ -n "$SOURCE_PATH" ]; then
                            echo "    + Bundling missing dependency: $DEP_NAME"
                            cp "$SOURCE_PATH" "$FRAMEWORKS_PATH/"
                            # CRITICAL: Make writable for install_name_tool and signing
                            chmod 755 "$FRAMEWORKS_PATH/$DEP_NAME"
                            install_name_tool -id "@rpath/$DEP_NAME" "$FRAMEWORKS_PATH/$DEP_NAME"
                            CHANGES_MADE=true
                        else
                            if [[ "$DEP" != "@rpath"* ]] && [[ "$DEP" != "@executable_path"* ]]; then
                                echo "    ! WARNING: Could not find source for $DEP"
                            fi
                        fi
                    fi
                    
                    # Case 2: Fix the Linkage
                    if [[ "$DEP" != "@rpath/$DEP_NAME" ]] && [[ "$DEP" != "@executable_path"* ]] && [[ "$DEP" != "@loader_path"* ]]; then
                         # Make sure binary is writable before modification
                         chmod u+w "$BINARY"
                         echo "    * Relinking $DEP -> @rpath/$DEP_NAME in $(basename "$BINARY")"
                         install_name_tool -change "$DEP" "@rpath/$DEP_NAME" "$BINARY" 2>/dev/null || true
                    fi
                done
            done

            if [ "$CHANGES_MADE" = false ]; then
                echo "Dependency walk complete."
                break
            fi
        done

        # --- PART C: FINAL CLEANUP ---
        
        echo "### 4. Cleaning up artifacts..."
        find "$APP_BUNDLE_PATH" -name "*_debug.dylib" -delete 2>/dev/null || true
        find "$APP_BUNDLE_PATH" -name "*.prl" -delete 2>/dev/null || true
        find "$APP_BUNDLE_PATH" -type d -name "Headers" -path "*/Frameworks/*" -exec rm -rf "{}" + 2>/dev/null || true

        echo "### 5. Cleaning RPaths..."
        clean_rpaths "$APP_EXECUTABLE"
        install_name_tool -add_rpath "@executable_path/../Frameworks" "$APP_EXECUTABLE" 2>/dev/null || true
        
        find "$FRAMEWORKS_PATH" -type f -name "*.dylib" | while read dylib; do
            clean_rpaths "$dylib"
        done
        
        echo "### 6. Verification..."
        if [ -f "$FRAMEWORKS_PATH/QtDBus.framework/Versions/A/QtDBus" ]; then echo "✓ QtDBus verified"; else echo "✗ QtDBus missing"; exit 1; fi
        if [ -f "$FRAMEWORKS_PATH/libgeos.3.14.1.dylib" ] || [ -f "$FRAMEWORKS_PATH/libgeos_c.1.dylib" ]; then echo "✓ GEOS verified"; fi
        
        # ==============================================================================
        # END OF REPLACEMENT SECTION
        # ==============================================================================

        echo "### 7. Code Signing (FINAL STEP)..."
        echo "CRITICAL: Removing ALL existing signatures to avoid Team ID conflicts..."
        
        echo "Removing signatures from all dylibs..."
        find "$FRAMEWORKS_PATH" -type f -name "*.dylib" -exec codesign --remove-signature {} \; 2>/dev/null || true
        find "$FRAMEWORKS_PATH" -type f -path "*/Versions/*/Qt*" ! -name "*.h" ! -name "*.prl" -exec codesign --remove-signature {} \; 2>/dev/null || true
        find "$FRAMEWORKS_PATH" -type d -name "*.framework" -exec codesign --remove-signature {} \; 2>/dev/null || true
        find "$FRAMEWORKS_PATH" -type d -name "*.app" -exec codesign --remove-signature {} \; 2>/dev/null || true
        codesign --remove-signature "$APP_EXECUTABLE" 2>/dev/null || true
        
        echo "Signing from inside out..."
        
        # Step 1: Sign all dylibs
        echo "1. Signing dylibs..."
        find "$FRAMEWORKS_PATH" -type f -name "*.dylib" | sort | while read lib; do
            codesign --force --sign - "$lib" 2>/dev/null || true
        done
        
        # Step 2: Sign all framework binaries
        echo "2. Signing framework binaries..."
        find "$FRAMEWORKS_PATH" -type f -path "*/Versions/*/Qt*" ! -name "*.h" ! -name "*.prl" | sort | while read fwlib; do
            codesign --force --sign - "$fwlib" 2>/dev/null || true
        done
        
        # Step 3: Sign the frameworks themselves
        echo "3. Signing frameworks..."
        find "$FRAMEWORKS_PATH" -type d -name "*.framework" -maxdepth 1 | sort | while read fw; do
            codesign --force --sign - "$fw" 2>/dev/null || true
        done
        
        # Step 4: Sign any helper apps
        echo "4. Signing helper apps..."
        find "$FRAMEWORKS_PATH" -type d -name "*.app" | sort | while read helper; do
            for HELPER_EXEC in "$helper/Contents/MacOS/"*; do
                if [ -f "$HELPER_EXEC" ]; then
                    codesign --force --sign - "$HELPER_EXEC" 2>/dev/null || true
                fi
            done
            codesign --force --deep --sign - "$helper" 2>/dev/null || true
        done
        
        # Step 5: Sign the main executable
        echo "5. Signing main executable..."
        codesign --force --sign - "$APP_EXECUTABLE"
        
        # Step 6: Sign the entire bundle
        echo "6. Signing entire bundle..."
        codesign --force --deep --sign - "$APP_BUNDLE_PATH"
        
        echo "### 8. Verify signatures..."
        codesign --verify --verbose "$APP_BUNDLE_PATH" && echo "✓ Signature valid" || echo "✗ Signature verification failed (may still work)"
        
        echo "Deployment complete!"

     
    - name: zip the app
      run: |
        cd $HOME/source/OpenSpace/bin/Release
        zip -r OpenSpaceapp.zip OpenSpace.app

    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        # Artifact name
        name: OpenSpace-MacOS15-AppleSilicon-app
        path: /Users/runner/source/OpenSpace/bin/Release/OpenSpaceapp.zip

    - name: Prepare and deploy (MacOS)
      shell: bash
      run: |
        openSpaceHome="$HOME/source/OpenSpace"
        cd "$openSpaceHome"
        echo "### Deploying for MacOS (Release build)"

        # Define variables
        APP_NAME="OpenSpace"
        APP_BUNDLE_PATH="bin/Release/$APP_NAME.app"
                
        # Prepare staging folder
        mkdir -p deploy_staging
        mkdir -p deploy_staging/bin
        mv "$APP_BUNDLE_PATH" deploy_staging/bin

        # Copy text files
        cp ACKNOWLEDGMENTS.md deploy_staging/
        cp CITATION.cff deploy_staging/
        cp CODE_OF_CONDUCT.md deploy_staging/
        cp COMMIT.md deploy_staging/
        cp CREDITS.md deploy_staging/
        cp LICENSE.md deploy_staging/
        cp README.md deploy_staging/

        # Copy data folders
        cp -R config deploy_staging/
        cp -R data deploy_staging/
        cp -R modules deploy_staging/
        cp -R scripts deploy_staging/
        cp -R shaders deploy_staging/
        cp openspace.cfg deploy_staging/
        
        if [ ! -z "$sync" ]; then
             cp -R $sync deploy_staging/
        fi

        # 3. Zip the result
        echo "### Create main zip file"
        cd deploy_staging
        
        zip -r -9 -y ../OpenSpace-minimal-daily-mac-qt-bundled.zip . \
          -x "*.git*" \
          -x "*.DS_Store"

        echo "Deployment package created: OpenSpace-minimal-daily-mac.zip"

    - name: Upload Artifact
      uses: actions/upload-artifact@v4
      with:
        name: OpenSpace-MacOS15-AppleSilicon-minimal
        path: /Users/runner/source/OpenSpace/OpenSpace-minimal-daily-mac-qt-bundled.zip

    - name: Upload .app to GitHub Release
      run: |
        RELEASE_TAG="daily-MacOS-app-single-precision"
        APP_FILE=/Users/runner/source/OpenSpace/bin/Release/OpenSpaceapp.zip
        MINZIP_FILE=/Users/runner/source/OpenSpace/OpenSpace-minimal-daily-mac-qt-bundled.zip
    
        gh release view "$RELEASE_TAG" >/dev/null 2>&1 || \
          gh release create "$RELEASE_TAG" -t "OpenSpace MacOS AppleSilicon Daily Build" -n "Automated daily .app build of OpenSpace."
    
        gh release edit "$RELEASE_TAG" \
          -t "OpenSpace-single-precision MacOS AppleSilicon Build" \
          -n "Automated build of OpenSpace - patched to single-precision - (updated $(date '+%Y-%m-%d %H:%M:%S') UTC).  Please see documentation at https://github.com/hn-88/OpenSpace-single-precision/wiki  . You may be asked to permit running this app from an unknown publisher - please see https://github.com/hn-88/OpenSpace-AppImage/wiki/How-to-run-unsigned-apps-on-Mac . Please note all the issues at https://github.com/hn-88/OpenSpace-AppImage/issues?q=is%3Aissue%20state%3Aopen%20Mac%20build"
    
        gh release upload "$RELEASE_TAG" "$MINZIP_FILE" --clobber
        
      env:
        GITHUB_TOKEN: ${{ secrets.PAT }}
